# 동기 vs 비동기 & 블로킹 vs 논블로킹

## 1. 동기(Synchronous) vs 비동기(Asynchronous)
**동기와 비동기는 요청을 처리하는 방식에 관한 개념입니다.**

- **동기(Synchronous)**: 특정 요청에 대한 **응답이 도착해야지만** 다음 요청을 처리합니다.
- **비동기(Asynchronous)**: 특정 요청에 대한 **응답이 도착하지 않더라도** 다음 작업을 실행할 수 있습니다.

### ✅ 동기 처리 예시
```java
System.out.println("작업 1 시작");
Thread.sleep(2000); // 2초 대기 (응답이 도착할 때까지 기다림)
System.out.println("작업 1 완료 후, 작업 2 시작");
```

### ✅ 비동기 처리 예시
```java
System.out.println("작업 1 시작");
new Thread(() -> {
    try { Thread.sleep(2000); } catch (InterruptedException e) {}
    System.out.println("작업 1 완료");
}).start();
System.out.println("작업 2 즉시 실행");
```

## 2. 블로킹(Blocking) vs 논블로킹(Non-Blocking)
블로킹과 논블로킹은 스레드의 처리 방식에 관한 개념입니다.

블로킹(Blocking): 스레드가 특정 작업을 수행하는 동안 다른 작업을 처리하지 못하고 대기합니다.
논블로킹(Non-Blocking): 스레드가 특정 작업을 수행하는 동안 다른 작업을 동시에 처리할 수 있습니다.
### ✅ 블로킹 처리 예시
```java
BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
String input = reader.readLine(); // 사용자 입력을 받을 때까지 블로킹됨
System.out.println("입력값: " + input);
```
### ✅ 논블로킹 처리 예시
```java
new Thread(() -> {
    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    try {
        String input = reader.readLine();
        System.out.println("입력값: " + input);
    } catch (IOException e) {
        e.printStackTrace();
    }
}).start();
System.out.println("사용자 입력과 상관없이 실행");
```

## 3. 동기/비동기 vs 블로킹/논블로킹 관계 정리

| 구분 | 동기(Synchronous) | 비동기(Asynchronous) |
|------|----------------|----------------|
| **블로킹(Blocking)** | 요청 후 응답이 올 때까지 대기 | 비동기 요청이지만 응답이 올 때까지 대기 |
| **논블로킹(Non-Blocking)** | 요청 후 응답을 기다리지 않지만, 다른 작업을 즉시 처리하지 않음 | 요청 후 응답을 기다리지 않고, 다른 작업을 즉시 수행 |

- **동기 + 블로킹**: 일반적인 함수 호출 (요청 후 응답을 받을 때까지 기다림)
- **동기 + 논블로킹**: 요청을 보낸 후, 일정 간격으로 응답을 확인 (폴링 방식)
- **비동기 + 블로킹**: 비동기 요청을 보내지만, 결과가 올 때까지 기다림 (Future.get())
