
### 객체지향 프로그래밍 정의

객체지향 프로그래밍이란 데이터와 함수를추상화시켜 상태와 행위를 가진 객체로 만들고, 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.

<aside>
💡

절차적 프로그래밍이란?

객체지향 프로그래밍은 객체들의 상호작용을 기준으로 프로그램을 구성하는 방법이라면 절차적 프로그래밍이란 프로그램을 절차나 함수의 연속적인 호출을 중심으로 구성하는 방식이다.

</aside>

### 객체지향 원칙

객체지향 프로그래밍은 캡슐화(Encapsulation), 상속(Inheritance), 다형성(Polymorphism), 추상화(Abstraction)의 4대 원칙을 기반으로 설계된다.

1. **캡슐화**
    
    데이터와 메서드를 하나의 객체 안에 묶고, 외부에서 접근하지 못하도록 보호하는 원칙이다.
    
    - 객체 내부의 데이터를 **숨기고(`private`)**,
    - 데이터를 변경하거나 접근할 때는 **메서드(`getter`, `setter`)를 통해 제어**하는 방식이다.
    
    이를 통해 객체 내부 상태를 외부로부터 은닉하여 유지보수성과 보안성을 높일 수 있다.
    
2. **상속**
    
    기존 클래스의 속성과 기능을 새로운 클래스(자식 클래스)가 물려받아 확장한다는 개념입니다. 이를 통해 코드 재사용성을 높이고, 중복을 줄일 수 있습니다.
    
3. **다형성**
    
    같은 메서드나 인터페이스가 다양한 방식으로 동작할 수 있도록 하는 원칙.
    
    - 오버로딩: 같은 이름의 메서드를 매개변수의 타입이나 개수에 따라 다르게 정의
    - 오버라이딩: 부모 클래스의 메서드를 자식 클래에서 재정의
    - 업캐스팅: 자식 클래스 객체를 부모 클래스 타입으로 변환하는 것
    - 
    
    <aside>
    ❓
    
    오버로딩
    
    - 같은 함수명, 같은 파라미터일 때 리턴 타입이 달라도 오버로디의 예시이다 (O/X)
    </aside>
    
    <aside>
    ❓
    
    업캐스팅
    
    - 업캐스팅된 객체는 하위 클래스에서 정의된 멤버(메서드, 변수)들이 접근 가능하다 (O/X)
    - 업캐스팅 후 오버라이딩된 메서드는 자식 클래스의 것이 실행된다 (O/X)
    </aside>
    
4. **추상화**
    
    필요한 정보만을 보여주고, 복잡한 내부 구현은 숨기는 원칙
    
    - 추상클래스/인터페이스를 사용하여 설계
    - 객체가 가져야 할 공통적인 특성을 정의하고, 세부 구현은 서브클래스에서 처리.
    - 유지보수성과 확장성이 증가하며, 의존성을 줄일 수 있음.

### 좋은 객체지향 설계 5가지 원칙: SOLID

SOLID는 객체지향 설계 원칙 중 하나로, **유지보수성과 확장성이 좋은 소프트웨어를 설계하기 위한 다섯 가지 원칙**을 의미한다.

- **S**: 단일 책임 원칙 (**Single Responsibility Principle, SRP**)
    - "하나의 클래스는 하나의 책임(기능)만 가져야 한다.”
    - 여러 책임을 가지면 기능이 변경될 때 연쇄적인 수정이 필요해 유지보수가 어려워진다.
- **O**: 개방-폐쇄 원칙 (**Open-Closed Principle, OCP**)
    - "확장에는 열려 있어야 하지만, 수정에는 닫혀 있어야 한다.”
    - 기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있도록 설계해야 한다.
    - `인터페이스`나 `추상 클래스`를 사용하여 확장 가능하도록 만들어야 한다.
- **L**: 리스코프 치환 원칙 (**Liskov Substitution Principle, LSP**)
    - "자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다.”
    - 상속을 사용할 때 부모 클래스의 기능을 변경하거나 제한하면 안된다는 원칙 (예측할 수 없는 동작이 발생할 수 있기 때문)
- **I**: 인터페이스 분리 원칙 (**Interface Segregation Principle, ISP**)
    - 하나의 큰 인터페이스보다는 **여러 개의 작은 인터페이스로 분리**해야 한다.
    - 인터페이스가 너무 크면, 필요 없는 메서드까지 구현해야 하는 문제가 발생한다.
- **D**: 의존 역전 원칙 (**Dependency Inversion Principle, DIP**)
    - 구현체가 아닌 **인터페이스 또는 추상 클래스에 의존해야 한다.**
    - 그 이유는 하위 모듈(구현체)는 변경이 상대적으로 자주 발생해, 구현체에 의존하는 객체들도 수정해야 하여 확장이 힘듦.
