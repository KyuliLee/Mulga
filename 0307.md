
# AOP (Aspect Oriented Programming)

### 정의

- AOP(Aspect Oriented Programming)는 핵심 관심사와 공통(부가) 관심사를 분리하여 모듈성을 높이는 프로그래밍 패러다임입니다.
    - 핵심 관심사 (core concern): 비즈니스 로직을 구현하는 주요 기능
    - 공통 관심사(cross-cutting concern): 로깅, 보안, 트랜잭션 관리 등 여러 모듈에서 공통적으로 사용되는 기능

### 장점

- 코드의 재사용성과 유지보수성을 높일 수 있다.

### 탄생 배경

- 전통적인 OOP(객체 지향 프로그래밍)에서는 공통 관심사를 각 클래스에 중복 구현하게 되어 코드가 복잡해지고, 유지보수가 어려워지는 문제가 발생했습니다.
- AOP는 이러한 문제를 해결하기 위해 등장하였습니다. 공통 관심사를 'Aspect'로 정의하고, 이를 비즈니스 로직과 분리하여 OOP를 적용하면서도 코드를 더 간결하고 이해하기 쉽게 만들 수 있습니다.
    
    ```python
    # before (OOP)
    def 파스타_만들기():
        손_씻기()
        앞치마_착용()
        # 파스타 조리 과정
        청소하기()
    
    def 스테이크_굽기():
        손_씻기()
        앞치마_착용()
        # 스테이크 굽는 과정
        청소하기()
    
    #-------------------------------
    # after (with AOP)
    @요리_준비_및_마무리
    def 파스타_만들기():
        # 파스타 조리 과정만 작성
    
    @요리_준비_및_마무리
    def 스테이크_굽기():
        # 스테이크 굽는 과정만 작성
    
    def 요리_준비_및_마무리(요리_함수):
        def wrapper():
            손_씻기()
            앞치마_착용()
            요리_함수()
            청소하기()
        return wrapper
    
    ```
    

### AOP 적용 예시

- 간단한 메소드의 성능 검사
    - 개발 도중 특히 DB에 대량의 데이터를 넣고 빼는 등의 배치 작업에 대하여 시간을 측정해 보고 쿼리를 개선하는 작업은 매우 의미가 있다. 이 경우 매번 해당 메소드의 처음과 끝에 System.currentTimeMillis()를 사용하거나, 스프링이 제공하는 StopWatch코드를 사용하기는 매우 번거로움
    - 이런 경우 해당 작업을 하는 코드를 밖에서 설정하고 해당 부분을 사용하는 것이 편리함
- 트랜잭션 처리
    - 트랜잭션의 경우 비즈니스 로직의 전후에 설정
    - 하지만 매번 사용하는 트랜잭션(try{ ~~~ }catch{}부분)의 코드는 번거롭고, 소스를 더욱 복잡하게 보여줌
- 예외 반환
    - 스프링에는 DataAccessException이라는 매우 잘 정의되어 있는 예외 계층 구조가 있음
    - 예전 Hibernate 예외들은 몇 개 없었고 그나마도 UncatchedException이 아니었음
    - 이렇게 구조가 별로 안 좋은 예외들이 발생했을 때, 그걸 잡아서 잘 짜여 되어있는 예외 계층 구조로 변환해서 다시 던지는 Aspect는 제 3의 프레임워크를 사용할 때, 본인의 프레임워크나 애플리케이션에서 별도의 예외 계층 구조로 변환하고 싶을 때 유용
- 아키텍처 검증
- 기타
    - Hibernate와 JDBC를 같이 사용할 경우, DB 동기화 문제 해결
    - 멀티스레드 Safety 관련하여 작업해야 하는 경우, 메소드들에 일괄적으로 락을 설정하는 Aspect
    - 데드락등으로 인한 PessimisticLockingFailureException등의 예외를 만났을 때 재시도하는 Aspect
    - 로깅, 인증, 관한 등 ...

### AOP의 주요 개념

- **Aspect**
    - 공통 관심사를 정의하는 모듈
    - AOP의 기본 모둘
    - aspect = advice + pointcut
    - aspect는 singleton 형태의 객체로 존재
    - 종류
        - before
        - after
        - after throwing
        - after returning
        - around
- **Join Point**
    - Aspect가 적용될 수 있는 시점
    - join point 종류
        - **메서드 호출**: 특정 메서드를 호출하는 순간
        - **메서드 실행**: 메서드가 실행되기 직전과 직후
        - **예외 발생**: 특정 예외가 발생했을 때
        - **객체 생성**: 객체가 생성되는 순간
        - **필드 접근**: 클래스의 속성에 접근하는 순간
- **Advice**
    - Join Point에서 실행되는 코드 (예: 로깅, 보안 체크)
        
        ```java
        @After("serviceMethods()")
        public void logAfterMethod() {
            System.out.println("메서드 실행 후 로그를 남깁니다.");
        }
        ```
        
- **Pointcut**
    - 어떤 Join Point에 Advice를 적용할지 정의합니다.
    - advice를 적용할 target의 method를 선별하는 정규 표현식
    - pointcut 표현식은 execution으로 시작하고, method의 Signature를 비교하는 방법을 주로 이용
    - ex. `"execution(* com.example.service.*.*(..))"`
- **Target**
    - 핵심기능을 담고 있는 모듈로, aspect(부가기능)을 부여할 대상
- **Advisor**
    - advisor = advice + pointcut
    - Advisor는 Spring AOP에서만 사용되는 특별한 용어
- **Weaving**
    - 어떤 Advice를 어떤 Pointcut(핵심사항)에 적용시킬 것인지에 대한 설정(Advisor)
    - 즉 Pointcut에 의해서 결정된 타깃의 JoinPoint에 부가기능(Advice)를 삽입하는 과정을 뜻함
    - Weaving은 AOP의 핵심기능(Target)의 코드에 영향을 주지 않으면서 필요한 부가기능(Advice)을 추가할 수 있도록 해주는 핵심적인 처리과정

### Spring AOP 특징 - Proxy 기반

- Spring은 proxy 기반 AOP를 지원
    - Spring은  target 객체에 대한 proxy를 만들어 제공함으로써 AOP를 지원한다.
    - 작동 방식
        - 클라이언트가 target 메서드 호출
        - 프록시가 호출을 가로챈다 (intercept)
            - target 메서드 호출될 때, 실제로는 target을 감싸는 프록시가 생성 및 호출된다 (proxy는 실행시간(runtime)에 생성)
            - 호출을 가로챈 프록시는 advice 부가기능 로직을 수행한 이후 target 핵심 기능 로직을 호출한다.
            - 또는, target 핵심 기능 로직을 호출 이후, advice 수행함
- Spring AOP는 method JoinPoint만 지원
    - Spring은 동적 프록시를 기반으로 AOP를 구현하므로 method JoinPOint만 지원
        - 즉, target 메서드가 호출되는 런타임 시점에만 부가기능 적용 가능
    - 반면 AspectJ 같은 고급 AOP framework를 사용하면, 객체의 생성, 필드값의 조회와 조작, static method 호출 및 초기화 등의 다양한 작업에 부가기능을 적용할 수 이씅ㅁ
