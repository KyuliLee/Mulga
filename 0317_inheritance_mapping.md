# JOIN vs. 서브쿼리 비교

## ✅ JOIN이 더 빠른 경우
1. **인덱스가 잘 설계된 경우**  
   - `JOIN`은 **두 테이블을 한 번에 결합하고 필터링**하므로, **인덱스**가 있으면 성능이 좋음  
   - 예제:
     ```sql
     SELECT t.id, u.name 
     FROM timeline_log t
     JOIN users u ON t.user_id = u.id
     WHERE t.type = 'TODO';
     ```
   - **장점**: 데이터 정규화 유지, 인덱스 최적화 가능  

2. **대량 데이터 처리 시**  
   - 여러 개의 서브쿼리는 각각의 쿼리를 실행한 후 병합해야 하지만, `JOIN`은 한 번에 결합하여 결과를 가져옴  
   - 대량 데이터에서는 **서브쿼리보다 JOIN이 성능상 우수한 경우가 많음**  

3. **JOIN으로만 해결할 수 있는 문제**  
   - `JOIN`을 사용하면 **한 번의 쿼리에서 여러 테이블의 데이터를 가져올 수 있음**  
   - 반면 서브쿼리는 각 쿼리별로 실행해야 하므로 **쿼리 실행 횟수가 증가**  

---

## ✅ 서브쿼리가 더 빠른 경우
1. **데이터 양이 적고 특정 값 조회가 목적일 때**  
   - 서브쿼리는 작은 테이블에서 필터링한 후 결과를 가져올 때 유리  
   - 예제:
     ```sql
     SELECT * FROM timeline_log 
     WHERE user_id = (SELECT id FROM users WHERE email = 'test@example.com');
     ```
   - 서브쿼리가 **단순한 경우**, 인덱스가 잘 적용되면 효율적임  

2. **복잡한 연산이 필요한 경우**  
   - `JOIN`은 여러 개의 큰 테이블을 결합하면 메모리 사용량이 급증  
   - 서브쿼리는 특정 조건을 먼저 필터링하여 작은 데이터셋을 반환하므로 **메모리 절약 가능**  

3. **특정 데이터에만 접근하는 경우**  
   - 예를 들어, `EXISTS`를 활용하면 **불필요한 데이터 조회를 줄일 수 있음**  
   - 예제:
     ```sql
     SELECT * FROM timeline_log t 
     WHERE EXISTS (SELECT 1 FROM users u WHERE u.id = t.user_id AND u.status = 'active');
     ```
   - `EXISTS`를 사용하면 **필요한 데이터만 조회할 수 있어 효율적**  

---

## 🔥 결론: 언제 JOIN을 쓰고, 언제 서브쿼리를 쓸까?

| 경우 | JOIN | 서브쿼리 |
|------|------|------|
| **대량 데이터 조회** | ✅ 빠름 | ❌ 느릴 수 있음 |
| **잘 인덱싱된 테이블 결합** | ✅ 빠름 | ❌ 비효율적 |
| **필터링 후 소량 데이터 조회** | ❌ 오버헤드 있음 | ✅ 빠름 |
| **복잡한 연산 (EXISTS, NOT EXISTS)** | ❌ 비효율적 | ✅ 빠름 |
| **테이블 정규화 및 관계 유지** | ✅ 적합 | ❌ 부적합 |

### 👉 결론:
- 대부분의 경우 **JOIN이 빠름** (인덱스 활용 가능, 한 번의 실행으로 처리)
- 하지만 **소량 데이터 조회, 특정 조건 필터링(EXISTS 등)은 서브쿼리가 더 효율적**

즉, **데이터 양, 인덱스 여부, 실행 계획을 보고 판단해야 함!** 🚀

---

# Inheritance Mapping (상속 매핑)

## ✅ 상속 매핑 전략
JPA에서 엔티티 상속을 매핑하는 방법에는 세 가지 주요 전략이 있음:

1. **JOINED 전략 (`@Inheritance(strategy = InheritanceType.JOINED)`)**
   - 서브클래스마다 별도의 테이블을 생성하고, 부모 테이블과 `JOIN`을 수행하여 데이터를 조회
   - 장점: 정규화된 구조, 데이터 중복 최소화
   - 단점: 조회 시 `JOIN` 필요 → 성능 저하 가능
   
2. **SINGLE_TABLE 전략 (`@Inheritance(strategy = InheritanceType.SINGLE_TABLE)`)**
   - 모든 데이터를 하나의 테이블에 저장, 구분 컬럼 (`@DiscriminatorColumn`)을 사용하여 유형 식별
   - 장점: `JOIN` 없이 빠르게 조회 가능
   - 단점: 불필요한 NULL 값 증가 가능 (불필요한 컬럼 차지)
   
3. **TABLE_PER_CLASS 전략 (`@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)`)**
   - 서브클래스별로 개별 테이블을 생성하고, 부모 테이블을 생성하지 않음
   - 장점: 독립적인 테이블 구조, `JOIN`이 필요 없음
   - 단점: 쿼리 시 여러 테이블을 조회해야 하므로 성능 저하 가능

## ✅ 어떤 전략을 선택해야 할까?
| 전략 | 장점 | 단점 |
|------|------|------|
| **JOINED** | 데이터 정규화, 중복 최소화 | `JOIN` 성능 저하 가능 |
| **SINGLE_TABLE** | `JOIN` 없이 빠름 | 불필요한 NULL 값 증가 가능 |
| **TABLE_PER_CLASS** | 독립적인 테이블 구조 | 조회 시 여러 테이블을 검색해야 함 |

### 👉 결론:
- **데이터 정규화가 필요하고, 중복을 최소화하려면 `JOINED` 전략 사용**
- **조회 성능이 중요하고, 데이터 중복이 적다면 `SINGLE_TABLE` 전략 사용**
- **독립적인 테이블이 필요하고, 객체 구조를 그대로 유지하려면 `TABLE_PER_CLASS` 전략 사용**
